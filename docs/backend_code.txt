api/router.py:

# api/router.py

from rest_framework_nested import routers

# Customer / Auth
from customer.views import AuthViewSet, UserViewSet, RoleViewSet

# Homelife
from homeLife.views import HouseholdViewSet, ChoreViewSet, SharedCalendarEventViewSet

# Finances
from finances.views import BankAccountViewSet, BudgetViewSet, TransactionViewSet

# School (split by domain)
from school.views.university_views import UniversityViewSet
from school.views.course_views import CourseViewSet
from school.views.topic_views import TopicViewSet         # <- Make sure you have a TopicViewSet
from school.views.assignment_views import AssignmentViewSet
from school.views.submission_views import SubmissionViewSet
from school.views.study_document_views import StudyDocumentViewSet  # <- Your newly added StudyDocumentViewSet
from school.views.discussion_views import DiscussionThreadViewSet, DiscussionPostViewSet

# Work
from work.views import TeamViewSet, ProjectViewSet, WorkTaskViewSet

# Investing
from investing.views import PortfolioViewSet, AssetViewSet, TradeTransactionViewSet

# Notifications
from notifications.views import NotificationViewSet


router = routers.DefaultRouter()

# Auth / Users / Roles
router.register(r'auth', AuthViewSet, basename='auth')
router.register(r'users', UserViewSet, basename='users')
router.register(r'roles', RoleViewSet, basename='roles')

# Homelife
router.register(r'households', HouseholdViewSet, basename='households')
router.register(r'chores', ChoreViewSet, basename='chores')
router.register(r'shared-events', SharedCalendarEventViewSet, basename='sharedcalendar')

# Finances
router.register(r'bank-accounts', BankAccountViewSet, basename='bankaccounts')
router.register(r'budgets', BudgetViewSet, basename='budgets')
router.register(r'transactions', TransactionViewSet, basename='transactions')

# Work
router.register(r'teams', TeamViewSet, basename='teams')
router.register(r'projects', ProjectViewSet, basename='projects')
router.register(r'worktasks', WorkTaskViewSet, basename='worktasks')

# School - University / Course / Topic / Assignment / Submission / StudyDocument
router.register(r'university', UniversityViewSet, basename='university')
router.register(r'course', CourseViewSet, basename='course')
router.register(r'topics', TopicViewSet, basename='topics')
router.register(r'assignments', AssignmentViewSet, basename='assignments')
router.register(r'submissions', SubmissionViewSet, basename='submissions')
router.register(r'study-documents', StudyDocumentViewSet, basename='studydocuments')

# School - Discussion (threads and posts)
router.register(r'discussion-threads', DiscussionThreadViewSet, basename='discussionthreads')
router.register(r'discussion-posts', DiscussionPostViewSet, basename='discussionposts')

# Investing
router.register(r'portfolios', PortfolioViewSet, basename='portfolios')
router.register(r'assets', AssetViewSet, basename='assets')
router.register(r'trade-transactions', TradeTransactionViewSet, basename='tradetransactions')

# Notifications
router.register(r'notifications', NotificationViewSet, basename='notifications')

kobrasuitecore/settings.py:

# kobrasuitecore/settings.py

import os
from pathlib import Path
from dotenv import load_dotenv
from datetime import timedelta
import django

load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent
STATIC_ROOT = BASE_DIR / 'staticfiles'
SECRET_KEY = os.getenv('SECRET_KEY')
DEBUG = os.getenv('DEBUG') == 'True'
ALLOWED_HOSTS = os.getenv('ALLOWED_HOSTS', '').split()
CSRF_TRUSTED_ORIGINS = os.getenv('CSRF_TRUSTED_ORIGINS', '').split()
CORS_ALLOWED_ORIGINS = os.getenv('CORS_ALLOWED_ORIGINS', '').split()
CORS_ALLOWED_ORIGIN_REGEXES = [
    r"^http://localhost:\d+$",
    r"^http://127\.0\.0\.1:\d+$",
]
CORS_ALLOW_CREDENTIALS = True

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework.authtoken',
    'rest_framework',
    'rest_framework_nested',
    'corsheaders',
    'drf_yasg',
    'rest_framework_simplejwt.token_blacklist',

    'channels',
    'redis',

    'api',
    'customer',
    'finances',
    'homelife',
    'investing',
    'notifications',
    'school',
    'work',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
]

ROOT_URLCONF = 'kobrasuitecore.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'kobrasuitecore.wsgi.application'
ASGI_APPLICATION = 'kobrasuitecore.asgi.application'  # Required for Channels

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DBNAME'),
        'HOST': os.getenv('DBHOST'),
        'USER': os.getenv('DBUSER'),
        'PASSWORD': os.getenv('DBPASS'),
        'PORT': '5432',
        'OPTIONS': {
            'sslmode': os.getenv('DBOPTIONS', 'prefer'),
        },
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True
STATIC_URL = '/static/'
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
AUTH_USER_MODEL = 'customer.User'
AUTHENTICATION_BACKENDS = [
    'customer.backends.RolePermissionBackend',
    'django.contrib.auth.backends.ModelBackend',
]
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 100,
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
    'JTI_CLAIM': 'jti',
}

SWAGGER_SETTINGS = {
    'SECURITY_DEFINITIONS': {
        'Bearer': {
            'type': 'apiKey',
            'in': 'header',
            'name': 'Authorization',
        }
    },
}

# Determine if we are running tests so we can optionally switch channel layer:
TESTING = (os.getenv('TESTING') == 'True' or 'pytest' in os.getenv('PYTEST_CURRENT_TEST', ''))

if TESTING:
    # Use in-memory channel layer for tests (no Redis needed)
    CHANNEL_LAYERS = {
        'default': {
            'BACKEND': 'channels.layers.InMemoryChannelLayer',
        },
    }
    # Optionally also override caching for tests if needed
    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
            'LOCATION': 'test-cache',
        }
    }
else:
    # Production or dev environment with Redis
    CHANNEL_LAYERS = {
        'default': {
            'BACKEND': 'channels_redis.core.RedisChannelLayer',
            'CONFIG': {
                'hosts': [('redis', 6379)],  # e.g. 'redis' container name, or 127.0.0.1
            },
        },
    }
    CACHES = {
        'default': {
            'BACKEND': 'django_redis.cache.RedisCache',
            'LOCATION': 'redis://redis:6379/0',
            'OPTIONS': {
                'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            }
        }
    }

DJANGO_ALLOW_ASYNC_UNSAFE = 1

kobrasuitecore/asgi.py:

# kobrasuitecore/asgi.py
import os
import django
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application
from school.routing import websocket_urlpatterns
from school.tests.middleware import JWTAuthMiddlewareStack  # <-- Use your custom JWT middleware

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'kobrasuitecore.settings')
django.setup()

django_asgi_app = get_asgi_application()

application = ProtocolTypeRouter({
    "http": django_asgi_app,
    "websocket": JWTAuthMiddlewareStack(
        URLRouter(websocket_urlpatterns)
    ),
})

kobrasuitecore/urls.py:

# kobrasuitecore/urls.py

from django.contrib import admin
from django.urls import path, include
from api.router import router

from rest_framework import permissions
from drf_yasg.views import get_schema_view
from drf_yasg import openapi

from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
    TokenVerifyView,
)

schema_view = get_schema_view(
    openapi.Info(
        title="KobraSuite API",
        default_version='v1',
        description="API documentation for KobraSuite project",
        terms_of_service="https://www.example.com/terms/",
        contact=openapi.Contact(email="you@example.com"),
        license=openapi.License(name="BSD License"),
    ),
    public=True,
    permission_classes=[permissions.AllowAny],
)

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include(router.urls)),

    # JWT Authentication Endpoints
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('api/token/verify/', TokenVerifyView.as_view(), name='token_verify'),

    # Swagger UI:
    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'),
    # Redoc UI:
    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='schema-redoc'),
]

customer/models.py:

from django.db import models
from django.contrib.auth.models import AbstractUser, Permission
from django.core.validators import RegexValidator
from django.utils import timezone
from django.conf import settings

from .types import MFAType
from school.models import University, Course


class User(AbstractUser):
    """
    Custom User model extending Django's AbstractUser.
    Adds phone verification and email verification, plus custom roles.
    """
    phone_regex = RegexValidator(
        regex=r'^\+?1?\d{9,15}$',
        message="Phone number must be in the format: '+999999999'. Up to 15 digits allowed."
    )
    phone_number = models.CharField(
        validators=[phone_regex],
        max_length=17,
        blank=True,
        null=True
    )
    is_email_verified = models.BooleanField(default=False)
    is_phone_verified = models.BooleanField(default=False)

    def has_role(self, role_name: str) -> bool:
        return self.roles.filter(name=role_name).exists()

    def __str__(self):
        return self.username


class Role(models.Model):
    """
    A Role, which can be assigned permissions and then associated with users.
    """
    name = models.CharField(max_length=50, unique=True)
    description = models.TextField(null=True, blank=True)
    permissions = models.ManyToManyField(
        Permission,
        blank=True,
        related_name='roles'
    )
    users = models.ManyToManyField(
        'User',
        related_name='roles',
        blank=True
    )

    def __str__(self):
        return self.name


class MFAConfig(models.Model):
    """
    MFA / 2-Factor Authentication model for user security settings.
    """
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    mfa_enabled = models.BooleanField(default=False)
    mfa_type = models.CharField(
        max_length=50,
        choices=MFAType.choices,
        null=True,
        blank=True
    )
    secret_key = models.CharField(max_length=255, null=True, blank=True)

    def __str__(self):
        return f"MFAConfig for {self.user.username}"


class UserProfile(models.Model):
    """
    Profile for a user, containing personal details like date of birth,
    address, and other preferences.
    """
    user = models.OneToOneField(
        User,
        on_delete=models.CASCADE,
        related_name='profile'
    )
    date_of_birth = models.DateField(null=True, blank=True)
    address = models.TextField(null=True, blank=True)
    profile_picture = models.ImageField(
        upload_to='profile_pics/',
        null=True,
        blank=True
    )
    preferences = models.JSONField(null=True, blank=True)

    def __str__(self):
        return f"Profile of {self.user.username}"


class SchoolProfile(models.Model):
    """
    A separate model to hold academic details for a user, such as
    their University and any Courses in which they're enrolled.
    """
    user = models.OneToOneField(
        User,
        on_delete=models.CASCADE,
        related_name='school_profile'
    )
    university = models.ForeignKey(
        University,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='school_profiles'
    )
    courses = models.ManyToManyField(
        Course,
        related_name='school_profiles',
        blank=True
    )

    def __str__(self):
        return f"School Profile of {self.user.username}"


class SecureDocument(models.Model):
    """
    A secure file uploaded by a user, separate from the study documents
    used for school.
    """
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='documents'
    )
    title = models.CharField(max_length=100)
    file = models.FileField(upload_to='secure_documents/')
    description = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(default=timezone.now)

    def __str__(self):
        return f"{self.title} - {self.user.username}"
		
customer/serializers.py:

# customer/serializers.py

from django.contrib.auth.password_validation import validate_password
from rest_framework import serializers
from django.contrib.auth import get_user_model, authenticate
from school.models import Course
from .models import Role, UserProfile, SchoolProfile
from school.serializers import UniversitySerializer
from rest_framework import serializers
from rest_framework_simplejwt.tokens import RefreshToken

User = get_user_model()


class UserProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserProfile
        fields = [
            'date_of_birth', 'address', 'profile_picture', 'preferences',
        ]


class SchoolProfileSerializer(serializers.ModelSerializer):
    university_detail = UniversitySerializer(source='university', read_only=True)
    courses = serializers.PrimaryKeyRelatedField(
        many=True,
        queryset=Course.objects.all(),
        required=False
    )

    class Meta:
        model = SchoolProfile
        fields = ['university', 'university_detail', 'courses']


class UserSerializer(serializers.ModelSerializer):
    profile = UserProfileSerializer(required=False)
    school_profile = SchoolProfileSerializer(required=False)

    class Meta:
        model = User
        fields = [
            'id', 'username', 'email', 'phone_number',
            'is_email_verified', 'is_phone_verified',
            'profile', 'school_profile',
        ]

    def update(self, instance, validated_data):
        profile_data = validated_data.pop('profile', None)
        school_profile_data = validated_data.pop('school_profile', None)
        user = super().update(instance, validated_data)

        if profile_data:
            profile_instance = getattr(user, 'profile', None)
            if not profile_instance:
                profile_instance = UserProfile.objects.create(user=user)

            # Update only the fields provided in profile_data
            for attr, value in profile_data.items():
                setattr(profile_instance, attr, value)
            profile_instance.save()

        if school_profile_data:
            school_profile_instance = getattr(user, 'school_profile', None)
            if not school_profile_instance:
                school_profile_instance = SchoolProfile.objects.create(user=user)

            for attr, value in school_profile_data.items():
                setattr(school_profile_instance, attr, value)
            if 'courses' in school_profile_data:
                courses = school_profile_data.pop('courses')
                school_profile_instance.courses.set(courses)
            school_profile_instance.save()

        return user


class RegisterSerializer(serializers.ModelSerializer):
    confirm_password = serializers.CharField(write_only=True)
    access = serializers.CharField(read_only=True)
    refresh = serializers.CharField(read_only=True)

    class Meta:
        model = User
        fields = [
            'username',
            'email',
            'phone_number',
            'password',
            'confirm_password',
            'access',
            'refresh',
        ]
        extra_kwargs = {
            'password': {'write_only': True},
        }

    def validate(self, attrs):
        if attrs['password'] != attrs['confirm_password']:
            raise serializers.ValidationError({"password": "Passwords do not match."})
        # Validate using Django’s built-in password validators
        validate_password(attrs['password'], self.instance)
        return attrs

    def create(self, validated_data):
        validated_data.pop('confirm_password', None)
        password = validated_data.pop('password')
        user = User(**validated_data)
        user.set_password(password)
        user.save()

        # Generate tokens with SimpleJWT
        refresh = RefreshToken.for_user(user)
        return {
            'user': user,
            'access': str(refresh.access_token),
            'refresh': str(refresh),
        }

    def to_representation(self, instance):
        """
        instance is the dict returned by create().
        So `instance['user']` is a User object,
        `instance['access']` is the token string, etc.
        """
        user = instance['user']
        access = instance['access']
        refresh = instance['refresh']
        user_data = UserSerializer(user).data

        return {
            'user': user_data,
            'access': access,
            'refresh': refresh,
        }


class LoginSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField(style={"input_type": "password"}, write_only=True)
    access = serializers.CharField(read_only=True)
    refresh = serializers.CharField(read_only=True)

    def validate(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')

        if not username or not password:
            raise serializers.ValidationError("Must include username and password.")

        # Use Django's built-in authenticate(), which uses AUTHENTICATION_BACKENDS
        user = authenticate(username=username, password=password)
        if not user:
            raise serializers.ValidationError("Invalid credentials.")

        if not user.is_active:
            raise serializers.ValidationError("User account is disabled.")

        # Generate JWT tokens for this user
        refresh = RefreshToken.for_user(user)
        attrs['user'] = user
        attrs['access'] = str(refresh.access_token)
        attrs['refresh'] = str(refresh)

        return attrs

    def to_representation(self, instance):
        """
        instance is just the validated_data we returned from `validate()`.
        So instance['user'] is a User object,
        instance['access'] is the token string, etc.
        """
        user = instance['user']
        access = instance['access']
        refresh = instance['refresh']
        user_data = UserSerializer(user).data

        return {
            'user': user_data,
            'access': access,
            'refresh': refresh,
        }


class RoleSerializer(serializers.ModelSerializer):
    class Meta:
        model = Role
        fields = '__all__'
		
customer/views.py:

# customer/views.py

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from django.db.utils import IntegrityError
from django.contrib.auth import authenticate, get_user_model
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.exceptions import TokenError

from .models import Role
from .permissions import IsOwner
from .serializers import (
    RegisterSerializer,
    LoginSerializer,
    UserSerializer,
    RoleSerializer
)


class AuthViewSet(viewsets.GenericViewSet):
    """
    Handles User Registration, Login, Logout, and whoami endpoints.
    """
    queryset = Role.objects.all()

    def get_serializer_class(self):
        if self.action == 'register':
            return RegisterSerializer
        elif self.action == 'login':
            return LoginSerializer
        elif self.action == 'logout':
            return LoginSerializer
        elif self.action == 'whoami':
            return UserSerializer
        return UserSerializer

    def get_permissions(self):
        if self.action in ['register', 'login']:
            self.permission_classes = [AllowAny]
        elif self.action == 'logout':
            self.permission_classes = [IsAuthenticated]
        else:
            self.permission_classes = [IsAuthenticated]
        return super().get_permissions()

    @action(methods=['post'], detail=False)
    def register(self, request):
        serializer = self.get_serializer(data=request.data)
        if serializer.is_valid():
            try:
                result = serializer.save()  # This calls create() on RegisterSerializer
            except IntegrityError:
                return Response(
                    {"success": False, "errors": "Username or email already taken."},
                    status=status.HTTP_409_CONFLICT
                )
            return Response(
                {
                    "success": True,
                    "message": "User registered successfully.",
                    **serializer.data  # The serializer's to_representation()
                },
                status=status.HTTP_201_CREATED
            )

        # Validation failed
        return Response(
            {"success": False, "errors": serializer.errors},
            status=status.HTTP_400_BAD_REQUEST
        )

    @action(methods=['post'], detail=False)
    def login(self, request):
        serializer = self.get_serializer(data=request.data)
        if serializer.is_valid():
            # serializer.data -> triggers to_representation()
            return Response(
                {
                    "success": True,
                    "message": "Logged in successfully.",
                    **serializer.data
                },
                status=status.HTTP_200_OK
            )
        else:
            errors = serializer.errors
            invalid_credentials = False
            # If you want to detect "Invalid credentials." specifically,
            # ensure that "non_field_errors" is how the serializer is raising it.
            # Or just check if "Invalid credentials" is in the top-level message.
            if 'Invalid credentials.' in str(errors):
                invalid_credentials = True

            return Response(
                {"success": False, "errors": errors},
                status=status.HTTP_401_UNAUTHORIZED if invalid_credentials else status.HTTP_400_BAD_REQUEST
            )

    @action(methods=['post'], detail=False)
    def logout(self, request):
        # Expecting the refresh token to blacklist it
        refresh_token = request.data.get("refresh")
        if not refresh_token:
            return Response(
                {"success": False, "errors": "Refresh token is required."},
                status=status.HTTP_400_BAD_REQUEST
            )
        try:
            token = RefreshToken(refresh_token)
            token.blacklist()
            return Response(
                {"success": True, "message": "Logged out successfully."},
                status=status.HTTP_200_OK
            )
        except TokenError:
            return Response(
                {"success": False, "errors": "Invalid or expired refresh token."},
                status=status.HTTP_400_BAD_REQUEST
            )

    @action(methods=['get'], detail=False)
    def whoami(self, request):
        serializer = UserSerializer(request.user)
        return Response({"user": serializer.data}, status=status.HTTP_200_OK)


class UserViewSet(viewsets.ModelViewSet):
    queryset = get_user_model().objects.all()
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticated, IsOwner]

    def get_queryset(self):
        return get_user_model().objects.filter(id=self.request.user.id)


class RoleViewSet(viewsets.ModelViewSet):
    queryset = Role.objects.all()
    serializer_class = RoleSerializer
    permission_classes = [IsAuthenticated]
	
customer/utils.py:

def assign_role_to_user(user, role_name):
    from .models import Role
    try:
        role = Role.objects.get(name=role_name)
        user.roles.add(role)
    except Role.DoesNotExist:
        raise ValueError(f"Role '{role_name}' does not exist")


def remove_role_from_user(user, role_name):
    from .models import Role
    try:
        role = Role.objects.get(name=role_name)
        user.roles.remove(role)
    except Role.DoesNotExist:
        pass
		
customer/types.py:

from django.db import models

class MFAType(models.TextChoices):
    TOTP = "TOTP", "Time-Based OTP"
    SMS = "SMS", "SMS"
    PUSH = "PUSH", "Push Notification"


customer/signals.py:

from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth import get_user_model
from .models import UserProfile, SchoolProfile

User = get_user_model()


@receiver(post_save, sender=User)
def create_profiles(sender, instance, created, **kwargs):
    if created:
        if not SchoolProfile.objects.filter(user=instance).exists():
            SchoolProfile.objects.create(user=instance)
        if not UserProfile.objects.filter(user=instance).exists():
            UserProfile.objects.create(user=instance)



@receiver(post_save, sender=User)
def save_profiles(sender, instance, **kwargs):
    if hasattr(instance, 'user_profile'):
        instance.user_profile.save()
    if hasattr(instance, 'school_profile'):
        instance.school_profile.save()
		
customer/backends.py:

# customer/backends.py

from django.contrib.auth.backends import ModelBackend
from django.contrib.auth.models import Permission


class RolePermissionBackend(ModelBackend):
    def get_role_permissions(self, user_obj):
        if not hasattr(user_obj, 'roles'):
            return set()

        role_permissions_qs = Permission.objects.filter(
            roles__users=user_obj
        ).distinct()

        return {
            f"{perm.content_type.app_label}.{perm.codename}"
            for perm in role_permissions_qs
        }

    def get_all_permissions(self, user_obj, obj=None):
        if not user_obj.is_active or user_obj.is_anonymous:
            return set()
        builtin_perms = super().get_all_permissions(user_obj, obj=obj)
        role_perms = self.get_role_permissions(user_obj)
        return builtin_perms.union(role_perms)

    def has_perm(self, user_obj, perm, obj=None):
        if user_obj.is_superuser:
            return True
        return perm in self.get_all_permissions(user_obj, obj=obj)
		
customer/permissions.py:

# customer/permissions.py

from rest_framework import permissions

class IsOwner(permissions.BasePermission):
    """
    Custom permission to only allow users to edit their own profiles.
    """

    def has_object_permission(self, request, view, obj):
        return obj == request.user
		
school/models.py:

# school/models.py

from django.db import models
from django.conf import settings
from django.utils import timezone
from .types import DiscussionScope  # Moved the enum to a separate file

class University(models.Model):
    name = models.CharField(max_length=255)
    country = models.CharField(max_length=100)
    domain = models.CharField(max_length=100)
    website = models.URLField(blank=True)
    state_province = models.CharField(max_length=100, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ('name', 'country', 'domain')

    def __str__(self):
        return self.name

    @property
    def student_count(self):
        return self.school_profiles.count()

    @property
    def course_count(self):
        return self.courses.count()


class Course(models.Model):
    course_code = models.CharField(max_length=50, blank=True, null=True)
    professor_last_name = models.CharField(max_length=100, blank=True, null=True)
    title = models.CharField(max_length=200)
    description = models.TextField(blank=True, null=True)
    semester = models.CharField(max_length=100, blank=True, null=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)
    university = models.ForeignKey(
        University,
        on_delete=models.CASCADE,
        related_name='courses',
        null=True,
        blank=True
    )
    students = models.ManyToManyField(
        settings.AUTH_USER_MODEL,
        related_name='courses',
        blank=True
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['title']

    def __str__(self):
        return self.title

    @property
    def student_count(self):
        return self.students.count()


class Topic(models.Model):
    name = models.CharField(max_length=200, blank=True, default='Untitled Topic')
    course = models.ForeignKey(
        Course,
        on_delete=models.CASCADE,
        related_name='topics'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f'Topic: {self.name} (Course: {self.course.title})'


class Assignment(models.Model):
    course = models.ForeignKey(
        Course,
        on_delete=models.CASCADE,
        related_name='assignments'
    )
    title = models.CharField(max_length=200)
    description = models.TextField(blank=True, null=True)
    due_date = models.DateTimeField()
    created_at = models.DateTimeField(default=timezone.now)

    class Meta:
        ordering = ['due_date']

    def __str__(self):
        return f'{self.title} ({self.course.title})'


class Submission(models.Model):
    assignment = models.ForeignKey(
        Assignment,
        on_delete=models.CASCADE,
        related_name='submissions'
    )
    student = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='submissions'
    )
    text_answer = models.TextField(blank=True, null=True)
    submitted_at = models.DateTimeField(auto_now_add=True)
    answer_file = models.FileField(upload_to='assignment_answers/', blank=True, null=True)
    comment = models.TextField(blank=True, null=True)

    class Meta:
        ordering = ['-submitted_at']

    def __str__(self):
        return f'Submission by {self.student.username} for {self.assignment.title}'


class StudyDocument(models.Model):
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='study_documents'
    )
    course = models.ForeignKey(
        Course,
        on_delete=models.CASCADE,
        related_name='documents'
    )
    topic = models.ForeignKey(
        Topic,
        on_delete=models.CASCADE,
        related_name='documents'
    )
    file = models.FileField(upload_to='study_documents/', blank=True, null=True)
    title = models.CharField(max_length=200)
    description = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(default=timezone.now)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f'Study Doc: {self.title}'


class DiscussionThread(models.Model):
    scope = models.CharField(max_length=50, choices=DiscussionScope.choices)
    scope_id = models.PositiveIntegerField()
    title = models.CharField(max_length=200)
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='discussion_threads'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return self.title


class DiscussionPost(models.Model):
    thread = models.ForeignKey(
        DiscussionThread,
        on_delete=models.CASCADE,
        related_name='posts'
    )
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='discussion_posts'
    )
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['created_at']

    def __str__(self):
        return f'Post by {self.author.username} in {self.thread.title}'
		
school/serializers.py:

# school/serializers.py
from django.utils import timezone
from rest_framework import serializers
from django.conf import settings
from .models import (
    University, Course, Topic, Assignment,
    Submission, StudyDocument, DiscussionThread, DiscussionPost
)

##################################################
#  UNIVERSITY
##################################################
class UniversitySerializer(serializers.ModelSerializer):
    student_count = serializers.IntegerField(read_only=True)
    course_count = serializers.IntegerField(read_only=True)

    class Meta:
        model = University
        fields = [
            'id', 'name', 'country', 'domain', 'website',
            'state_province', 'student_count', 'course_count',
        ]


##################################################
#  COURSE
##################################################
class CourseSerializer(serializers.ModelSerializer):
    student_count = serializers.IntegerField(read_only=True)
    # Store a reference to the university by ID if needed
    university_id = serializers.PrimaryKeyRelatedField(
        source='university',
        queryset=University.objects.all(),
        write_only=True,
        required=False
    )

    # If you want more details, you can do a "get_university" approach:
    university = serializers.SerializerMethodField()

    class Meta:
        model = Course
        fields = [
            'id', 'course_code', 'professor_last_name', 'title', 'description',
            'semester', 'start_date', 'end_date', 'created_at', 'student_count',
            'university', 'university_id',
        ]

    def get_university(self, obj):
        """
        Return minimal data about the related University, if any.
        """
        if obj.university:
            return {
                "id": obj.university.id,
                "name": obj.university.name,
                "country": obj.university.country,
            }
        return None


##################################################
#  TOPIC
##################################################
class TopicSerializer(serializers.ModelSerializer):
    # Link to a Course by ID
    course_id = serializers.PrimaryKeyRelatedField(
        source='course',
        queryset=Course.objects.all(),
        write_only=True
    )
    course = CourseSerializer(read_only=True)

    class Meta:
        model = Topic
        fields = [
            'id', 'name', 'course', 'course_id', 'created_at',
        ]


##################################################
#  ASSIGNMENT
##################################################
class AssignmentSerializer(serializers.ModelSerializer):
    course_id = serializers.PrimaryKeyRelatedField(
        source='course',
        queryset=Course.objects.all(),
        write_only=True
    )
    course = CourseSerializer(read_only=True)

    class Meta:
        model = Assignment
        fields = [
            'id', 'title', 'description', 'due_date',
            'created_at', 'course', 'course_id'
        ]

    def validate_due_date(self, value):
        if value < timezone.now():
            raise serializers.ValidationError("Due date cannot be in the past.")
        return value


##################################################
#  SUBMISSION
##################################################
class SubmissionSerializer(serializers.ModelSerializer):
    assignment_id = serializers.PrimaryKeyRelatedField(
        source='assignment',
        queryset=Assignment.objects.all(),
        write_only=True
    )
    assignment = AssignmentSerializer(read_only=True)
    # Typically, 'student' is read-only because we set it via code

    class Meta:
        model = Submission
        fields = [
            'id', 'assignment', 'assignment_id', 'student',
            'text_answer', 'submitted_at', 'answer_file', 'comment'
        ]
        read_only_fields = ['student', 'submitted_at']


##################################################
#  STUDY DOCUMENT
##################################################
class StudyDocumentSerializer(serializers.ModelSerializer):
    topic_id = serializers.PrimaryKeyRelatedField(
        source='topic',
        queryset=Topic.objects.all(),
        write_only=True
    )
    topic = TopicSerializer(read_only=True)

    class Meta:
        model = StudyDocument
        fields = [
            'id', 'author', 'course', 'topic', 'topic_id',
            'file', 'title', 'description', 'created_at',
        ]
        read_only_fields = ['author', 'course', 'created_at']


##################################################
#  DISCUSSION THREAD
##################################################
class DiscussionThreadSerializer(serializers.ModelSerializer):
    class Meta:
        model = DiscussionThread
        fields = [
            'id', 'scope', 'scope_id', 'title', 'created_by', 'created_at',
        ]


##################################################
#  DISCUSSION POST
##################################################
class DiscussionPostSerializer(serializers.ModelSerializer):
    class Meta:
        model = DiscussionPost
        fields = [
            'id', 'thread', 'author', 'content', 'created_at',
        ]
        read_only_fields = ['author', 'created_at']
		
school/views/assignment_views.py:

# school/views/assignment_views.py

import logging
from rest_framework import viewsets, status, mixins
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination
from rest_framework.filters import OrderingFilter
from django_filters.rest_framework import DjangoFilterBackend

from ..models import Assignment
from ..serializers import AssignmentSerializer, SubmissionSerializer
from ..filters import AssignmentFilter

logger = logging.getLogger(__name__)


class AssignmentViewSet(viewsets.ModelViewSet):
    """
    Manages CRUD for Assignments in the system, including:
      - Listing assignments with filtering/pagination
      - Creating new assignments for a course
      - Viewing detail, updating, deleting
      - Listing all submissions for a particular assignment
    """
    queryset = Assignment.objects.all()
    serializer_class = AssignmentSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = PageNumberPagination
    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filterset_class = AssignmentFilter
    ordering_fields = ['due_date', 'created_at']  # e.g. ?ordering=due_date
    ordering = ['due_date']

    def create(self, request, *args, **kwargs):
        """
        POST /assignments/
        Body must include a 'course_id'.
        The new assignment is tied to that course.
        """
        course_id = request.data.get('course_id')
        if not course_id:
            logger.warning("[ASSIGNMENT_VIEWS] Attempted to create assignment without 'course_id'.")
            return Response({"detail": "Missing course_id."}, status=status.HTTP_400_BAD_REQUEST)
        return super().create(request, *args, **kwargs)

    @action(detail=True, methods=['get'], url_path='submissions')
    def list_submissions(self, request, pk=None):
        assignment = self.get_object()
        submissions = assignment.submissions.all().order_by('-submitted_at')

        serializer = SubmissionSerializer(submissions, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)
		
school/views/course_views.py:

# school/views/course_views.py

import logging
from django.shortcuts import get_object_or_404
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination
from rest_framework.filters import OrderingFilter
from django_filters.rest_framework import DjangoFilterBackend

from ..models import Course
from ..serializers import CourseSerializer
from ..filters import CourseFilter
from ..services import course_service
from ..utils import validators

logger = logging.getLogger(__name__)


class CourseViewSet(viewsets.GenericViewSet):
    """
    Provides retrieval, searching, creating new courses in a user's
    current university, adding to profile, removing from profile, etc.
    """
    queryset = Course.objects.all()
    serializer_class = CourseSerializer
    permission_classes = [IsAuthenticated]

    # If you want to allow list with pagination & filtering:
    pagination_class = PageNumberPagination
    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filterset_class = CourseFilter
    ordering_fields = ['title', 'course_code', 'semester']
    ordering = ['title']

    def retrieve(self, request, pk=None):
        """
        GET /course/{id}/
        Return detailed info about the Course:
          - code, title, professor, semester, student_count, etc.
        """
        course = get_object_or_404(Course, pk=pk)
        serializer = self.get_serializer(course)
        return Response(serializer.data, status=status.HTTP_200_OK)

    @action(detail=False, methods=['get'], url_path='search_local')
    def search_local(self, request):
        """
        GET /course/search_local?query=someText
        Search partial matches in user's set University
        by code/title/professor.
        """
        school_profile = getattr(request.user, 'school_profile', None)
        if not school_profile or not school_profile.university:
            return Response({"detail": "No university set in profile."},
                            status=status.HTTP_400_BAD_REQUEST)
        query = request.query_params.get('query', '')
        data, code = course_service.search_course_in_university(
            school_profile.university, query
        )
        return Response(data, status=code)

    # school/views/course_views.py

    @action(detail=False, methods=['post'], url_path='add_new_course')
    def add_new_course(self, request):
        """
        POST /course/add_new_course
        Creates (or finds) a course in the user's university.
        Body must include: course_code, title, professor_last_name, (optional) description, semester
        """
        # 1. Check for course_code, title, etc. first:
        code = request.data.get('course_code')
        title = request.data.get('title')
        prof = request.data.get('professor_last_name')
        if not code or not title or not prof:
            # The test specifically wants "Missing course_code" if code is absent:
            if not code:
                return Response({"detail": "Missing course_code"}, status=status.HTTP_400_BAD_REQUEST)
            # If you also want to handle missing title/prof, do similarly:
            if not title:
                return Response({"detail": "Missing title"}, status=status.HTTP_400_BAD_REQUEST)
            if not prof:
                return Response({"detail": "Missing professor_last_name"}, status=status.HTTP_400_BAD_REQUEST)

        # 2. Check if user has a university set:
        school_profile = getattr(request.user, 'school_profile', None)
        if not school_profile or not school_profile.university:
            return Response({"detail": "No university set in profile."},
                            status=status.HTTP_400_BAD_REQUEST)

        # 3. Then proceed with creation:
        desc = request.data.get('description', '')
        semester = request.data.get('semester', '')

        # Optional advanced validation:
        from ..utils import validators
        if not validators.validate_course_code_format(code):
            return Response({"detail": "Invalid course_code format."},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            course, created = course_service.find_or_create_course_in_university(
                school_profile.university, code, title, prof, desc
            )
            if semester:
                course.semester = semester
                course.save()
            # Add to user's profile
            school_profile.courses.add(course)
            msg = "Course created and added." if created else "Course existed, added to profile."
            logger.info(f"[COURSE_VIEWS] {msg} -> (Code: {code}, User: {request.user.username})")
            return Response({"detail": msg}, status=status.HTTP_201_CREATED if created else status.HTTP_200_OK)
        except ValueError as e:
            logger.error(f"[COURSE_VIEWS] {str(e)}")
            return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=False, methods=['post'], url_path='add_to_profile')
    def add_to_profile(self, request):
        """
        POST /course/add_to_profile
        Body: { "course_id": <int> }
        """
        school_profile = getattr(request.user, 'school_profile', None)
        if not school_profile or not school_profile.university:
            return Response({"detail": "No university set in profile."},
                            status=status.HTTP_400_BAD_REQUEST)
        cid = request.data.get('course_id')
        if not cid:
            return Response({"detail": "Provide course_id."}, status=status.HTTP_400_BAD_REQUEST)

        data, code = course_service.add_course_to_school_profile(school_profile, cid)
        return Response(data, status=code)

    @action(detail=False, methods=['post'], url_path='remove-course')
    def remove_course(self, request):
        """
        POST /course/remove-course
        Body: { "course_id": <int> }
        Removes a course from user’s SchoolProfile.
        """
        school_profile = getattr(request.user, 'school_profile', None)
        if not school_profile:
            return Response(
                {"detail": "School profile not found."},
                status=status.HTTP_404_NOT_FOUND
            )
        cid = request.data.get('course_id')
        if not cid:
            return Response({"detail": "Provide course_id."}, status=status.HTTP_400_BAD_REQUEST)

        data, code = course_service.remove_course_from_school_profile(school_profile, cid)
        return Response(data, status=code)
		
school/views/discussion_views.py:

# school/views/discussion_views.py

import logging
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from ..models import DiscussionThread, DiscussionPost
from ..serializers import DiscussionThreadSerializer, DiscussionPostSerializer

logger = logging.getLogger(__name__)


class DiscussionThreadViewSet(viewsets.ModelViewSet):
    """
    Handles creation, retrieval, update, deletion of Discussion Threads,
    which are grouped by a scope: UNIVERSITY, COURSE, or ASSIGNMENT.
    """
    queryset = DiscussionThread.objects.all()
    serializer_class = DiscussionThreadSerializer
    permission_classes = [IsAuthenticated]

    def perform_create(self, serializer):
        """
        Automatically set the 'created_by' to the current user.
        """
        user = self.request.user
        logger.info(f"[DISCUSSION_VIEWS] Creating new DiscussionThread by {user.username}")
        serializer.save(created_by=user)

    @action(detail=False, methods=['get'])
    def by_scope(self, request):
        """
        GET /discussion-threads/by_scope?scope=COURSE&scope_id=123
        Return all threads matching the specified scope & scope_id.
        """
        scope = request.query_params.get('scope')
        scope_id = request.query_params.get('scope_id')
        if not scope or not scope_id:
            logger.warning("[DISCUSSION_VIEWS] Missing scope or scope_id in 'by_scope'.")
            return Response({"detail": "Provide scope and scope_id."}, status=status.HTTP_400_BAD_REQUEST)

        threads = DiscussionThread.objects.filter(scope=scope, scope_id=scope_id)
        serializer = DiscussionThreadSerializer(threads, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)


class DiscussionPostViewSet(viewsets.ModelViewSet):
    """
    Manages the actual posts within Discussion Threads.
    """
    queryset = DiscussionPost.objects.all()
    serializer_class = DiscussionPostSerializer
    permission_classes = [IsAuthenticated]

    def perform_create(self, serializer):
        """
        Automatically assign the current user as the 'author' of the post.
        """
        user = self.request.user
        logger.info(f"[DISCUSSION_VIEWS] Creating new DiscussionPost by {user.username}")
        serializer.save(author=user)

    @action(detail=False, methods=['get'])
    def for_thread(self, request):
        """
        GET /discussion-posts/for_thread?thread_id=XYZ
        Return all posts for a specific thread, sorted by creation date.
        """
        thread_id = request.query_params.get('thread_id')
        if not thread_id:
            return Response({"detail": "Provide thread_id."}, status=status.HTTP_400_BAD_REQUEST)

        posts = DiscussionPost.objects.filter(thread_id=thread_id).order_by('created_at')
        serializer = DiscussionPostSerializer(posts, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)
		
school/views/study_documents_views.py:

# school/views/study_document_views.py

import logging
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from rest_framework.parsers import JSONParser, MultiPartParser, FormParser
from ..models import StudyDocument
from ..serializers import StudyDocumentSerializer

logger = logging.getLogger(__name__)

class StudyDocumentViewSet(viewsets.ModelViewSet):
    """
    Provides full CRUD for StudyDocument objects, including file uploads.
    Relevant front-end features:
      - [TOPIC SLUG -> SLUG.2] Display Topic Study Documents
      - [TOPIC SLUG -> SLUG.3] Button to upload Study Document
      - [1c.1.1] A modern, industry standard document viewer (the front-end uses `file` from this model)
      - [1c.3] Document Uploader
    """
    queryset = StudyDocument.objects.all()
    serializer_class = StudyDocumentSerializer
    permission_classes = [IsAuthenticated]
    parser_classes = [JSONParser, MultiPartParser, FormParser]

    def perform_create(self, serializer):
        """
        When creating a new StudyDocument:
          - We infer the 'course' from the 'topic' the user selected
          - We automatically set 'author' to the request user
        """
        topic = serializer.validated_data['topic']  # Required field in serializer
        course = topic.course
        doc = serializer.save(author=self.request.user, course=course)
        logger.info(f"[StudyDocumentViewSet] Created document '{doc.title}' by user '{doc.author.username}' for topic ID {topic.id}, course '{course.title}'")
		
school/views/submission_views.py:

# school/views/submission_views.py

import logging
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.parsers import JSONParser, MultiPartParser, FormParser

from ..models import Submission
from ..serializers import SubmissionSerializer

logger = logging.getLogger(__name__)


class SubmissionViewSet(viewsets.ModelViewSet):
    """
    Handles creation, retrieval, update, and deletion of Submissions.
    Submissions are typically linked to an Assignment and a 'student' user.
    """
    queryset = Submission.objects.all()
    serializer_class = SubmissionSerializer
    permission_classes = [IsAuthenticated]
    parser_classes = [JSONParser, MultiPartParser, FormParser]

    def perform_create(self, serializer):
        """
        Automatically set the 'student' to the current user
        when a new submission is created.
        """
        student = self.request.user
        logger.info(f"[SUBMISSION_VIEWS] Creating submission by user {student.username}")
        serializer.save(student=student)

    @action(detail=True, methods=['post'], url_path='upload-answer')
    def upload_answer(self, request, pk=None):
        """
        POST /submissions/{id}/upload-answer
        Attach an answer_file to the existing submission (pk).
        Body must contain "answer_file" in FILES.
        """
        submission = self.get_object()
        file_obj = request.FILES.get('answer_file')
        if not file_obj:
            logger.warning("[SUBMISSION_VIEWS] No file provided in 'upload-answer'.")
            return Response({"detail": "No file provided."}, status=status.HTTP_400_BAD_REQUEST)

        submission.answer_file = file_obj
        submission.save()
        logger.info(f"[SUBMISSION_VIEWS] File uploaded for submission {submission.id}")
        return Response({"detail": "File uploaded successfully."}, status=status.HTTP_200_OK)
		
school/views/topic_views.py:

# school/views/topic_views.py

import logging
from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.shortcuts import get_object_or_404

from ..models import Topic, Course
from ..serializers import TopicSerializer

logger = logging.getLogger(__name__)


class TopicViewSet(viewsets.ModelViewSet):
    """
    Manage CRUD for Topics within a Course.
    E.g. "Week 1: Introduction"
    """
    queryset = Topic.objects.all()
    serializer_class = TopicSerializer
    permission_classes = [IsAuthenticated]

    def create(self, request, *args, **kwargs):
        """
        Must provide a 'course_id'.
        The front-end can show a button to create a new topic for a course.
        """
        course_id = request.data.get('course_id')
        if not course_id:
            logger.error("[TOPIC_VIEWS] No 'course_id' provided.")
            return Response({"detail": "Missing course_id."}, status=status.HTTP_400_BAD_REQUEST)
        # Optionally verify user is in that course, etc.
        return super().create(request, *args, **kwargs)

    def destroy(self, request, *args, **kwargs):
        """
        Optionally restrict who can delete a topic (e.g., only instructors).
        For demonstration, we allow standard DRF permission-based approach.
        """
        topic = self.get_object()
        logger.info(f"[TOPIC_VIEWS] Deleting Topic {topic.id} by user {request.user.username}")
        return super().destroy(request, *args, **kwargs)
		
school/views/university_views.py:

# school/views/university_views.py

import logging
from django.shortcuts import get_object_or_404
from rest_framework import viewsets, status, mixins
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.filters import OrderingFilter
from django_filters.rest_framework import DjangoFilterBackend

from ..models import University
from ..serializers import UniversitySerializer
from ..filters import UniversityFilter
from ..services.university_service import search_and_sync_universities

logger = logging.getLogger(__name__)


class UniversityViewSet(mixins.ListModelMixin,
                        mixins.RetrieveModelMixin,
                        viewsets.GenericViewSet):
    """
    Manages:
      - Listing Universities with filtering
      - Retrieving University details
      - Searching external API for new universities
      - Setting/Removing user's University
      - Listing that University’s courses
    """
    queryset = University.objects.all()
    serializer_class = UniversitySerializer
    permission_classes = [IsAuthenticated]

    # Filtering & ordering if you want to allow listing:
    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filterset_class = UniversityFilter
    ordering_fields = ['name', 'country']
    ordering = ['name']

    @action(
        detail=False,
        methods=['get'],
        url_path='search_universities',  # so endpoint = /university/search_universities
        name='search_universities'  # so route name = "university-search_universities"
    )
    def search_universities(self, request):
        """
        GET /university/search_universities?name=foo&country=bar
        Fetch from Hipolabs, upsert into DB, return results.
        """
        name = request.query_params.get('name')
        country = request.query_params.get('country')
        if not name and not country:
            logger.warning("[UNIVERSITY_VIEWS] Missing name or country in search.")
            return Response({"detail": "Provide name or country."}, status=status.HTTP_400_BAD_REQUEST)

        data, code = search_and_sync_universities(name, country)
        return Response(data, status=code)

    @action(detail=True, methods=['post'], url_path='set_as_my_university')
    def set_as_my_university(self, request, pk=None):
        """
        POST /university/{id}/set_as_my_university
        Ties the current user's SchoolProfile to this University.
        """
        university = self.get_object()
        user = request.user
        school_profile = getattr(user, 'school_profile', None)
        if not school_profile:
            logger.error(f"[UNIVERSITY_VIEWS] {user.username} has no SchoolProfile.")
            return Response({"detail": "SchoolProfile not found."}, status=status.HTTP_404_NOT_FOUND)

        school_profile.university = university
        school_profile.save()
        logger.info(f"[UNIVERSITY_VIEWS] {user.username} set university to {university.name}.")
        return Response({"detail": f"University '{university.name}' set successfully."},
                        status=status.HTTP_200_OK)

    @action(detail=True, methods=['post'], url_path='remove_as_my_university')
    def remove_as_my_university(self, request, pk=None):
        """
        POST /university/{id}/remove_as_my_university
        Unsets the current user's University if it matches pk.
        """
        university = self.get_object()
        user = request.user
        school_profile = getattr(user, 'school_profile', None)
        if not school_profile:
            logger.error(f"[UNIVERSITY_VIEWS] {user.username} has no SchoolProfile to remove from.")
            return Response({"detail": "SchoolProfile not found."}, status=status.HTTP_404_NOT_FOUND)

        if school_profile.university != university:
            logger.warning(f"[UNIVERSITY_VIEWS] {user.username} tried to remove unowned University {university.id}.")
            return Response({"detail": "You do not have this university set."},
                            status=status.HTTP_400_BAD_REQUEST)
        school_profile.university = None
        school_profile.save()
        logger.info(f"[UNIVERSITY_VIEWS] {user.username} removed university {university.name}.")
        return Response({"detail": f"University '{university.name}' removed."},
                        status=status.HTTP_200_OK)

    @action(
        detail=True,
        methods=['get'],
        url_path='courses',
    )
    def list_university_courses(self, request, pk=None):
        """
        GET /university/{id}/list-courses
        Return minimal course details for the specified university
        sorted by (course_code, semester).
        """
        uni = get_object_or_404(University, pk=pk)
        courses = uni.courses.all().order_by('course_code', 'semester')
        data = []
        for c in courses:
            data.append({
                "id": c.id,
                "course_code": c.course_code,
                "title": c.title,
                "semester": c.semester
            })
        return Response(data, status=status.HTTP_200_OK)

school/utils/external_api.py:

# school/services/external_api.py

import logging
import requests
from typing import Tuple, Any, Union
from rest_framework import status

logger = logging.getLogger(__name__)

HIPOLABS_URL = 'http://universities.hipolabs.com/search'

def fetch_universities_from_hipolabs(
    name: str = None,
    country: str = None,
    timeout: int = 5
) -> Tuple[Union[dict, list], int]:
    """
    Fetch universities from the Hipolabs API based on optional 'name' and 'country'.
    Returns a tuple of (response_data, status_code).
      - On success, response_data is a list of universities.
      - On failure, response_data is {"detail": <error message>}.
    Example usage:
      fetch_universities_from_hipolabs(name="MIT", country="United States")
    """
    params = {}
    if country:
        params['country'] = country
    if name:
        params['name'] = name

    logger.debug(f"[EXTERNAL_API] Fetching from Hipolabs with params={params}")
    try:
        response = requests.get(HIPOLABS_URL, params=params, timeout=timeout)
        if response.status_code == 200:
            # Return JSON list of unis
            data = response.json()
            if isinstance(data, list):
                return data, status.HTTP_200_OK
            # If unexpected structure, log an error
            logger.warning("[EXTERNAL_API] Unexpected response structure.")
            return {"detail": "Unexpected response format from Hipolabs."}, status.HTTP_500_INTERNAL_SERVER_ERROR
        # Non-200 code
        logger.error(f"[EXTERNAL_API] Error from Hipolabs: {response.status_code}, {response.text[:200]}")
        return {"detail": "Hipolabs error."}, response.status_code
    except requests.RequestException as e:
        # Catch connectivity, timeouts, etc.
        logger.error(f"[EXTERNAL_API] RequestException: {e}")
        return {"detail": str(e)}, status.HTTP_503_SERVICE_UNAVAILABLE
		
school/utils/validators.py:

# school/services/validators.py

import re
import logging
import os

try:
    import openai
    OPENAI_AVAILABLE = True
    openai.api_key = os.getenv("OPENAI_API_KEY", "")
except ImportError:
    OPENAI_AVAILABLE = False

logger = logging.getLogger(__name__)

COURSE_CODE_REGEX = re.compile(r'^[A-Za-z]{2,4}\d{3,4}$')


def validate_course_code_format(code: str) -> bool:
    """
    Check if 'code' matches a typical pattern: 
      2-4 letters + 3-4 digits (e.g., 'CS101', 'MATH240').
    """
    if not code:
        return False
    return bool(COURSE_CODE_REGEX.match(code))


def validate_course_with_chatgpt(course_code: str, title: str, professor_last_name: str) -> bool:
    """
    An example ChatGPT-based validation function.
    If OpenAI is available and an API key is configured, 
    we prompt GPT to judge whether the course is legitimate.
    Return True if GPT says "VALID" or if GPT is not available. 
    """
    if not OPENAI_AVAILABLE or not openai.api_key:
        # If openai not installed or no key, skip advanced validation
        logger.warning("[VALIDATORS] ChatGPT not available or no API key set. Skipping advanced validation.")
        return True

    prompt = (f"Validate whether a course code '{course_code}', titled '{title}', "
              f"taught by Prof. '{professor_last_name}' is legitimate. "
              "Reply ONLY 'VALID' or 'INVALID' with no extra text.")

    try:
        response = openai.Completion.create(
            model="text-davinci-003",
            prompt=prompt,
            max_tokens=2,
            temperature=0
        )
        gpt_reply = response.choices[0].text.strip()
        logger.debug(f"[VALIDATORS] GPT replied: {gpt_reply}")
        return (gpt_reply == "VALID")
    except Exception as e:
        logger.error(f"[VALIDATORS] ChatGPT validation error: {e}")
        return True  # default to True if GPT fails

#
# Optionally add more validators for phone numbers, emails, etc.
#
def validate_student_email(email: str) -> bool:
    """
    Example placeholder function for validating a student's email 
    or matching certain domain rules.  Expand as needed.
    """
    # For now, let's do a simple "contains '@'" check:
    return '@' in email
	
school/services/course_service.py:

# school/services/course_service.py

import logging
from typing import Tuple, Dict, Any
from django.db import transaction
from rest_framework import status
from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist

from ..models import Course, University
from ..serializers import CourseSerializer
from ..utils import validators

logger = logging.getLogger(__name__)


def find_or_create_course_in_university(
    university: University,
    course_code: str,
    title: str,
    professor_last_name: str,
    description: str = ""
) -> Tuple[Course, bool]:
    """
    Find an existing course in a given university by `course_code`,
    or create a new one if none is found.

    :param university: University instance
    :param course_code: e.g. 'CS101'
    :param title: 'Intro to Computer Science'
    :param professor_last_name: 'Smith'
    :param description: (Optional) 'This course covers...'
    :return: (Course instance, bool) -> bool indicates whether it was created (True) or found (False)
    """
    # Validate inputs using custom validators
    if not validators.validate_course_code_format(course_code):
        raise ValueError(f"Invalid course code format: '{course_code}'.")

    existing_course = Course.objects.filter(
        university=university, course_code=course_code
    ).first()
    if existing_course:
        return existing_course, False

    # Optionally call ChatGPT or other advanced validations
    # if not validators.validate_course_with_chatgpt(course_code, title, professor_last_name):
    #     raise ValueError("Course not validated by ChatGPT or external service.")

    with transaction.atomic():
        new_course = Course.objects.create(
            university=university,
            course_code=course_code,
            title=title,
            professor_last_name=professor_last_name,
            description=description
        )
    logger.info(
        f"[COURSE_SERVICE] Created new course '{title}' (code: {course_code}) in University '{university.name}'."
    )
    return new_course, True


def search_course_in_university(
    university: University,
    query: str
) -> Tuple[Any, int]:
    """
    Perform partial matches in the `university` for title, course_code, or professor_last_name.
    Returns serialized data + HTTP status code.

    :param university: The University to search within
    :param query: partial text
    :return: (data, status_code)
    """
    # Possibly expand logic with Q() for multi-field matches
    qs = Course.objects.filter(university=university).filter(
        course_code__icontains=query
    ) | Course.objects.filter(university=university).filter(
        title__icontains=query
    ) | Course.objects.filter(university=university).filter(
        professor_last_name__icontains=query
    )
    qs = qs.distinct()

    # Serialize
    serializer = CourseSerializer(qs, many=True)
    logger.debug(f"[COURSE_SERVICE] Found {qs.count()} courses matching '{query}' in '{university.name}'.")
    return serializer.data, status.HTTP_200_OK


def add_course_to_school_profile(school_profile, course_id: int) -> Tuple[Dict[str, str], int]:
    """
    Add an existing course (by ID) to a user's SchoolProfile.
    Ensures the course belongs to the user's current university.

    :param school_profile: The user’s SchoolProfile object
    :param course_id: ID of the course to add
    :return: (response_json, status_code)
    """
    try:
        course = Course.objects.get(id=course_id, university=school_profile.university)
    except ObjectDoesNotExist:
        logger.warning(f"[COURSE_SERVICE] Course {course_id} not found in University {school_profile.university}.")
        return {"detail": "Course not found in this university."}, status.HTTP_404_NOT_FOUND

    school_profile.courses.add(course)
    logger.info(f"[COURSE_SERVICE] Added course {course.course_code} to user {school_profile.user.username} profile.")
    return {"detail": "Course added to profile."}, status.HTTP_200_OK


def remove_course_from_school_profile(school_profile, course_id: int) -> Tuple[Dict[str, str], int]:
    """
    Remove a course from a user’s SchoolProfile if it’s currently associated.

    :param school_profile: The user’s SchoolProfile instance
    :param course_id: int
    :return: (response_json, status_code)
    """
    try:
        course = Course.objects.get(id=course_id)
    except ObjectDoesNotExist:
        logger.warning(f"[COURSE_SERVICE] Course {course_id} does not exist.")
        return {"detail": "Course not found."}, status.HTTP_404_NOT_FOUND

    if not school_profile.courses.filter(id=course_id).exists():
        logger.warning(f"[COURSE_SERVICE] Course {course_id} not in user {school_profile.user.username} profile.")
        return {"detail": "Course not in your courses."}, status.HTTP_404_NOT_FOUND

    school_profile.courses.remove(course)
    logger.info(f"[COURSE_SERVICE] Removed course {course_id} from user {school_profile.user.username} profile.")
    return {"detail": "Course removed."}, status.HTTP_200_OK
	
school/services/university_service.py:

# school/services/university_service.py

from rest_framework import status
from school.models import University
from school.serializers import UniversitySerializer
from school.utils.external_api import fetch_universities_from_hipolabs


def search_and_sync_universities(name=None, country=None):
    try:
        data, status_code = fetch_universities_from_hipolabs(name, country)
    except Exception as exc:
        # e.g. a timeout or any request failure
        return {"detail": str(exc)}, status.HTTP_503_SERVICE_UNAVAILABLE
    if status_code != 200:
        return data, status_code
    existing_unis = []
    for uni_data in data:
        uni_name = uni_data.get('name') or ''
        domains = uni_data.get('domains') or []
        websites = uni_data.get('web_pages') or []
        state_province = uni_data.get('state-province') or ''
        if len(domains) == 0:
            domain_str = ''
        else:
            domain_str = domains[0]
        if len(websites) == 0:
            website_str = ''
        else:
            website_str = websites[0]
        obj, created = University.objects.get_or_create(
            name=uni_name,
            country=uni_data.get('country', ''),
            domain=domain_str,
            website=website_str,
            state_province=state_province,
        )
        existing_unis.append(obj)
    serialized = UniversitySerializer(existing_unis, many=True)
    return serialized.data, status.HTTP_200_OK


def get_or_create_university_by_name_country(name, country):
    obj, created = University.objects.get_or_create(name=name, country=country, domain='')
    return obj
	
school/consumers.py:

# school/consumers.py

import json
import logging
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.core.exceptions import ObjectDoesNotExist
from .models import DiscussionThread, DiscussionPost
from .types import DiscussionScope

logger = logging.getLogger(__name__)

class SchoolChatConsumer(AsyncWebsocketConsumer):
    """
    A robust chat consumer for Universities, Courses, or Assignments:
      ws://<host>/ws/school-chat/<scope_type>/<scope_id>/
    """

    async def connect(self):
        """
        Join the group (room) for the scope_type and scope_id.
        """
        self.scope_type = self.scope['url_route']['kwargs']['scope_type']
        self.scope_id = self.scope['url_route']['kwargs']['scope_id']
        self.room_group_name = f"{self.scope_type}-{self.scope_id}"

        # Validate scope_type
        valid_scopes = [DiscussionScope.UNIVERSITY, DiscussionScope.COURSE, DiscussionScope.ASSIGNMENT]
        if self.scope_type not in valid_scopes:
            logger.debug(f"Invalid scope_type: {self.scope_type}")
            await self.close(code=4003)  # 4003 custom close code
            return

        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        await self.accept()

        # Send a presence event to others
        user_display = self.scope['user'].username if self.scope['user'].is_authenticated else 'Anonymous'
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'chat.presence',
                'status': 'joined',
                'user': user_display
            }
        )
        logger.debug(f"User {user_display} connected to group {self.room_group_name}")

    async def disconnect(self, close_code):
        """
        Leave the group and notify presence.
        """
        user_display = self.scope['user'].username if self.scope['user'].is_authenticated else 'Anonymous'
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

        # Send a presence event to others
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'chat.presence',
                'status': 'left',
                'user': user_display
            }
        )
        logger.debug(f"User {user_display} disconnected from group {self.room_group_name}")

    async def receive(self, text_data=None, bytes_data=None):
        """
        Handle incoming messages (JSON) from WebSocket.
        """
        if not text_data:
            return

        try:
            data = json.loads(text_data)
        except ValueError:
            logger.warning("Invalid JSON received.")
            return

        msg_type = data.get("type")
        if msg_type == "message":
            # A chat message
            content = data.get("content", "").strip()
            if content:
                await self.handle_chat_message(content)
        elif msg_type == "typing":
            # The user is typing...
            user_display = self.scope['user'].username if self.scope['user'].is_authenticated else 'Anonymous'
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'chat.typing',
                    'user': user_display
                }
            )
        else:
            # Unknown message type
            logger.debug(f"Unhandled message type: {msg_type}")

    async def chat_presence(self, event):
        """
        Called when a presence event is broadcast to the group.
        """
        logger.debug(f"Presence event: {event}")
        await self.send(text_data=json.dumps({
            "type": "presence",
            "status": event['status'],
            "user": event['user']
        }))

    async def chat_typing(self, event):
        """
        Called when a typing event is broadcast to the group.
        """
        logger.debug(f"Typing event: {event}")
        await self.send(text_data=json.dumps({
            "type": "typing",
            "user": event['user']
        }))

    async def chat_message(self, event):
        """
        Called when a chat message is broadcast to the group.
        """
        logger.debug(f"Chat message event: {event}")
        await self.send(text_data=json.dumps({
            "type": "message",
            "user": event['username'],
            "content": event['content']
        }))

    async def handle_chat_message(self, content: str):
        """
        Process a user chat message: store it in the DB, then broadcast it to the group.
        """
        user = self.scope['user']
        if not user.is_authenticated:
            logger.warning("Unauthenticated user attempted to send a message.")
            return

        # Persist the message to DiscussionPost
        post_id = await self.save_discussion_post(content)
        logger.debug(f"Message saved with post_id: {post_id}")

        # Broadcast to group
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'chat.message',
                'username': user.username,
                'content': content
            }
        )

    @database_sync_to_async
    def save_discussion_post(self, content: str) -> int:
        """
        Save a new DiscussionPost in a thread. Create thread if it doesn't exist.
        Return the new post's ID.
        """
        try:
            thread = DiscussionThread.objects.get(scope=self.scope_type, scope_id=self.scope_id)
        except ObjectDoesNotExist:
            thread = DiscussionThread.objects.create(
                scope=self.scope_type,
                scope_id=self.scope_id,
                title=f"Autogenerated thread: {self.scope_type}-{self.scope_id}",
                created_by=self.scope['user']
            )
            logger.debug(f"Created new thread: {thread.title}")

        post = DiscussionPost.objects.create(
            thread=thread,
            author=self.scope['user'],
            content=content
        )
        logger.debug(f"Created new post with ID: {post.id}")
        return post.id
		
school/filters.py:

# school/filters.py

import django_filters
from .models import University, Course, Assignment

class UniversityFilter(django_filters.FilterSet):
    """
    Filters for University based on name, country, or domain.
    E.g. /university/?name__icontains=Tech&country=United
    """
    name = django_filters.CharFilter(lookup_expr='icontains')
    country = django_filters.CharFilter(lookup_expr='icontains')
    domain = django_filters.CharFilter(lookup_expr='icontains')

    class Meta:
        model = University
        fields = ['name', 'country', 'domain']


class CourseFilter(django_filters.FilterSet):
    """
    Filters for Course based on course_code, title, professor, semester.
    E.g. /course/?course_code__icontains=101&professor_last_name=Smith
    """
    course_code = django_filters.CharFilter(lookup_expr='icontains')
    title = django_filters.CharFilter(lookup_expr='icontains')
    professor_last_name = django_filters.CharFilter(lookup_expr='icontains')
    semester = django_filters.CharFilter(lookup_expr='icontains')

    class Meta:
        model = Course
        fields = ['course_code', 'title', 'professor_last_name', 'semester']


class AssignmentFilter(django_filters.FilterSet):
    """
    Filters for Assignment based on title, due_date range, etc.
    """
    title = django_filters.CharFilter(lookup_expr='icontains')
    min_due_date = django_filters.DateTimeFilter(field_name='due_date', lookup_expr='gte')
    max_due_date = django_filters.DateTimeFilter(field_name='due_date', lookup_expr='lte')

    class Meta:
        model = Assignment
        fields = ['title', 'course', 'min_due_date', 'max_due_date']
		
school/routing.py:

# school/routing.py

"""
Channels WebSocket routing for the School app.
Handles chat connections for Universities, Courses, or Assignments.
"""

import logging

from channels.routing import ProtocolTypeRouter, URLRouter
from django.urls import re_path
from .consumers import SchoolChatConsumer
from school.tests.middleware import JWTAuthMiddlewareStack  # Ensure correct import

logger = logging.getLogger(__name__)

websocket_urlpatterns = [
    re_path(
        r'^ws/school-chat/(?P<scope_type>\w+)/(?P<scope_id>\d+)/$',
        SchoolChatConsumer.as_asgi(),
        name='school_chat'
    ),
]
application = ProtocolTypeRouter({
    "websocket": JWTAuthMiddlewareStack(
        URLRouter(
            websocket_urlpatterns
        )
    ),
    # Other protocols can be added here.
})
logger.debug("[ROUTING] WebSocket URLs for SchoolChatConsumer loaded.")

school/signals.py:

# school/signals.py

import logging
from django.db.models.signals import post_save, m2m_changed
from django.dispatch import receiver
from django.conf import settings
from .models import (
    University, Course, Assignment,
    Submission, DiscussionThread
)

logger = logging.getLogger(__name__)


@receiver(post_save, sender=University)
def university_created_signal(sender, instance, created, **kwargs):
    """
    Signal triggered after a University record is created or updated.
    If created, log or notify staff that a new University has been added.
    """
    if created:
        logger.info(f"[SIGNAL] New University created: {instance.name} "
                    f"(ID: {instance.id}, Country: {instance.country})")
        # E.g. send_email_to_staff(...), post_slack_message(...)


@receiver(post_save, sender=Course)
def course_created_signal(sender, instance, created, **kwargs):
    """
    Signal triggered after a Course record is created or updated.
    If created, we log the event and could also notify relevant staff or the course professor.
    """
    if created:
        logger.info(f"[SIGNAL] New Course created: {instance.title} "
                    f"(Code: {instance.course_code}, University: {instance.university})")
        # Additional logic, e.g. notify professor via email, etc.


@receiver(post_save, sender=Assignment)
def assignment_created_signal(sender, instance, created, **kwargs):
    """
    Signal triggered after an Assignment record is created or updated.
    If created, notify the course students about the new assignment.
    """
    if created:
        logger.info(f"[SIGNAL] New Assignment created: '{instance.title}' "
                    f"for Course '{instance.course.title}'.")
        # Example: notify course students
        # students = instance.course.students.all()
        # for student in students:
        #    send_notification(student, "New Assignment", ...)


@receiver(post_save, sender=Submission)
def submission_created_signal(sender, instance, created, **kwargs):
    """
    Signal triggered after a Submission record is created or updated.
    If created, we log and possibly notify the instructor or store analytics data.
    """
    if created:
        logger.info(f"[SIGNAL] New Submission by {instance.student.username} "
                    f"for Assignment '{instance.assignment.title}'.")
        # For instance, send a 'received submission' email to instructor


@receiver(post_save, sender=DiscussionThread)
def discussion_thread_created_signal(sender, instance, created, **kwargs):
    """
    Signal triggered after a DiscussionThread is created or updated.
    If created, log it or notify relevant participants.
    """
    if created:
        logger.info(f"[SIGNAL] New Discussion Thread created: '{instance.title}' "
                    f"(Scope: {instance.scope}, Scope ID: {instance.scope_id}).")
        # Potentially notify participants or watchers if this is a new thread.


@receiver(m2m_changed, sender=Course.students.through)
def course_students_changed_signal(sender, instance, action, reverse, pk_set, **kwargs):
    """
    This signal triggers when the many-to-many relationship between
    Course and students is modified (e.g., a user enrolls or is removed).
    """
    if action == "post_add":
        logger.info(f"[SIGNAL] Students {pk_set} were added to Course '{instance.title}' (ID: {instance.id}).")
    elif action == "post_remove":
        logger.info(f"[SIGNAL] Students {pk_set} were removed from Course '{instance.title}' (ID: {instance.id}).")
		
school/tasks.py:

# school/tasks.py

import logging
import datetime
from celery import shared_task
from django.utils import timezone
from .services.university_service import search_and_sync_universities
from .models import Submission, Assignment

logger = logging.getLogger(__name__)


@shared_task
def sync_universities_task(name=None, country=None):
    """
    A Celery task to fetch data from Hipolabs (or other external sources)
    and upsert into the local University table. 
    Can be triggered manually or via a periodic schedule.
    """
    data, status_code = search_and_sync_universities(name, country)
    if status_code == 200:
        logger.info(f"[TASK] Successfully synced universities. Count: {len(data)}")
    else:
        logger.error(f"[TASK] Failed to sync universities. Response: {data}")


@shared_task
def clean_old_submissions(days=180):
    """
    A Celery task to remove or archive Submissions older than `days` days 
    if your business logic calls for it. Alternatively, just mark them as inactive.
    """
    cutoff_date = timezone.now() - datetime.timedelta(days=days)
    old_submissions = Submission.objects.filter(submitted_at__lt=cutoff_date)
    count = old_submissions.count()

    # Example approach: delete them or mark them archived
    old_submissions.delete()
    logger.info(f"[TASK] Cleaned up {count} old Submissions older than {days} days.")


@shared_task
def remind_upcoming_assignments(hours_until_due=24):
    """
    A Celery task that notifies students about assignments 
    that are due soon (within the next X hours).
    """
    now = timezone.now()
    cutoff = now + datetime.timedelta(hours=hours_until_due)
    upcoming_assignments = Assignment.objects.filter(due_date__lte=cutoff, due_date__gte=now)

    for assignment in upcoming_assignments:
        # Potentially notify each enrolled student
        for student in assignment.course.students.all():
            # send_notification(student, 'Assignment due soon', ...)
            logger.info(f"[TASK] Reminding {student.username} about assignment '{assignment.title}'.")
			
school/types.py:

# school/types.py
from django.db import models

class DiscussionScope(models.TextChoices):
    UNIVERSITY = "UNIVERSITY", "University"
    COURSE = "COURSE", "Course"
    ASSIGNMENT = "ASSIGNMENT", "Assignment"

manage.py:

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'kobrasuitecore.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
